# Базовые принципы программирования

## Table of Contents

- [Glossary](#Glossary)

- [Design Principles](#Design-principles)

  - [SOLID](#SOLID)
  - [GOF](<>)
  - [GRASP](<>)

- [Принципы простоты и ясности](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D1%82%D1%8B-%D0%B8-%D1%8F%D1%81%D0%BD%D0%BE%D1%81%D1%82%D0%B8)

- [Принципы поведения и обработки ошибок](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%BF%D0%BE%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D1%8F-%D0%B8-%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8-%D0%BE%D1%88%D0%B8%D0%B1%D0%BE%D0%BA)

- [Принципы поддержки и тестирования](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B8-%D0%B8-%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

- [Принципы читамости и стиля](#%D0%9F%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D1%87%D0%B8%D1%82%D0%B0%D0%B5%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D0%B8-%D1%81%D1%82%D0%B8%D0%BB%D1%8F)

- [Short-term patterns](<>)

- [Middle-term & long-term patterns](<>)

- [Bibliography](#Bibliography)

- [Further reading](#Further-reading)

- [Quotes](#Quotes)

______________________________________________________________________

## Glossary

**DDD** -

**Предметная область** - множество всех предметов, свойства которых и отношения между которыми рассматриваются в научной теории.\
В логике: подразумеваемая область возможных значений предметных переменных логического языка.

условный оператор -

функциональные требования -

нефункциональные требования -

домент - (в контексте архитектуры ПО)

______________________________________________________________________

## Design Principles

### SOLID

```
S - Single Responsibility Principle (SRP): Принцип единственной ответственности. 
    Каждый класс должен иметь только одну причину для изменения, то есть он должен выполнять только одну задачу.
    Каждая сущность отвественна только за один сценарий.
    Нарушение SRP это содержание двух и более несвязанных или слабосвязанных между собой логических конструкций.
    В любом случае, SRP должен не усложнять код, а упрощать его. 
    Движение в обратную сторону с целью лишь следования SRP контрпродуктивно.

O - Open/Closed Principle (OCP): Принцип открытости/закрытости. 
    Программные сущности (классы, модули и функции) должны быть открыты для расширения, но закрыты для модификации. 
    Это означает, что поведение системы можно изменять, добавляя новый код, а не изменяя существующий.

L - Liskov Substitution Principle (LSP): Принцип подстановки Лисков. 
    Объекты подкласса должны быть взаимозаменяемыми с объектами суперкласса без изменения правильности программы. 
    Это гарантирует, что наследование используется корректно.

I - Interface Segregation Principle (ISP): Принцип разделения интерфейса. 
    Клиенты не должны зависеть от интерфейсов, которые они не используют. 
    Это означает, что лучше создавать несколько специализированных интерфейсов, чем один универсальный.

D - Dependency Inversion Principle (DIP): Принцип инверсии зависимостей. 
    Модули верхнего уровня не должны зависеть от модулей нижнего уровня. 
    Оба типа модулей должны зависеть от абстракций (интерфейсов). 
    Это помогает уменьшить связанность и повысить гибкость системы.
```

**Separation of Concerns**
Разделение кода на модули с четкими обязанностями.

### GOF

### GRASP

**General Responsibility Assignment Software Patterns**\
Это набор принципов, предназначенных для помощи в распределении обязанностей между классами и объектами в объектно-ориентированном программировании.\
Эти принципы помогают разработчикам создавать более понятные, гибкие и поддерживаемые системы.

Основные принципы GRASP:

#### Фундаментальные принципы

**1. High Cohesion**\
*Высокая связанность*\
Высокая связанность обязанностей внутри компонента. Когда поведение логически объединено и сфокусировано, система становится:

- Проще в поддержке
- Легче для понимания
- Надежнее при изменениях (?)

**2. Low Coupling**\
*Слабая связанность*\
Низкая связанность между компонентами. Чем меньше зависимостей между модулями, тем:

- Выше модульность
- Меньше каскадных изменений
- Легче тестировать и заменять части системы

**3. Information Expert**\
*Информационный эксперт*\
Ответственность назначается тому классу, который имеет наибольшее количество информации, необходимой для исполнения этой ответственности.\
Помогает избежать излишней зависимости между классами и позволяет:

- Повысить cohesion
- Снизить дублирование
- Избавиться от анимичных моделей
- Перейти к rich-доменту, где данные и поведение неразделимы

**4. Creator**\
*Создатель*\
Определить какой класс должен создавать экземпляры других классов.\
Класс, который содержит или использует необходимый объект, должен создавать его. (вроде как)\
Такой подход помогает:

- Снизить Coupling
- Локализовать ответственность
- Не выносить создание объектов в искусственные фабрики, если это не нужно

#### Инженерные надстройки

**1. Pure Fabrication**\
*Чистая отвественность*\
Предлагает создавать искусственные абстракции(нужны не бизнесу, а архитектуре), которые:

- Не отражают предметную область
- Но нужны для архитектурной чистоты
- Соблюдают принципы Low Coupling и High Cohesion\
  Классический пример - репозиторий. Это не бизнес-сущность, а прослойка между логикой и базой данных.

**2. Indirection**\
*Перенаправляение*\
Управление зависимостями через прослойки.\
Это паттерн, снижающий жесткую связанность компонентов.\
Он создает контролируемую прослойку между объектами и дает системе:

- управляемость
- гибкость
- возможность замены компонентов без каскадных правок\
  Indirection — это не просто «прокинуть вызов». Это может быть и обогащение данных, и трансформация интерфейса, и дополнительная логика, в зависимости от нужд системы.

**3. Controller**\
*Контроллер*\
Паттерн первого звена координации - первым получает внешние события и координирует поведение системы.

- Принимает входные данные
- Определяет сценарий
- Делегирует выполнение вглубь архитектуры

**4. Polymorphism**\
*Полиморфизм*

**5. Protected variations**\
*Защита от изменений*

______________________________________________________________________

## Принципы простоты и ясности

**KISS**
(Keep It Simple, Stupid).
Стремление к простоте.

**DRY**
(Don't Repeat Yourself).
Избежание дублирования кода.

**YAGNI**
(You Aren't Gonna Need It).
Избежание избыточности.

______________________________________________________________________

## Принципы поведения и обработки ошибок

**EAFP**
(Easier to Ask for Forgiveness than Permission).
Предпочтение обработки ошибок.

**LBIL**
(Look Before You Leap).
Проверка условий перед выполнением действий.

**POLA**
(Principle of Least Astonishment).
Ожидаемое поведение кода.

______________________________________________________________________

## Принципы поддержки и тестирования

**Testing**
Написание тестов для обеспечения корректности кода.

**Documentation**
Документирование кода для улучшения понимания.

**Version Control**
Использование систем контроля версий для отслеживания изменений.

______________________________________________________________________

## Принципы читаемости и стиля

**Code Readability**
Читаемость кода и следование стилю кодирования.

______________________________________________________________________

## Short-term patterns

______________________________________________________________________

## Middle-term & long-term patterns

______________________________________________________________________

## Bibliography

[GRASP: почему настоящая архитектура начинается не с SOLID](habr.com/ru/articles/900140/)

______________________________________________________________________

## Further reading

1. «Применение UML 2.0 и шаблонов проектирования» Крэг Ларман
2. «Domain Driven Design (DDD)» Эрик Эванс

______________________________________________________________________

## Quotes

Основной вектор это декомпозиция и борьба со сложностью (а не наоборот).\
"Слоирование" это основа всего. (Но так думают не все).\
[source](https://www.youtube.com/watch?v=WlCDcr8JYFU)
